##
#  CommonBuildRules.mk
#
#  Set of convenient rules for building application and shared
#  library for the MgNugget Platform
#
#  Must not be included directly.  It is expected to be included by
#  other generic engines.  See below for variables that the including
#  engine should define.
#
#  IMPORTANT:
#    * The including engine must include PalmUtils.mk manually.  This    *
#    * makefile makes use of things in PalmUtils.mk, but doesn't include *
#    * it (since it should be included at the top of the main engine).   *
#
#  This file is intended to be included by "build engine Makefiles" that
#  work within Palm's build system.  It is not completely universal and
#  shouldn't be--we don't want it to be super complex.  Please try to keep
#  the complexity down when you do this, since Makefiles are hard enough
#  to understand as it is.
#
#
#  One of the ways that we manage complexity here is to enforce STRICT
#  standards about the modules we build.  By limiting your flexibility,
#  we make the whole system easier to understand.  Here are limits:
#   * Source must be in "Src"
#   * Resources must be in "Rsc"
#   * Public/Protected includes must be in "Incs"
#   * You have no option to set CFLAGS, just to append to them.
#
#  ...we also force ourselves to use "simply expanded" variables (assigned
#  with ":=").  This forces us to change some orders around, but really
#  simplifies understanding.
#
#
#  Generally required to be set by the including ENGINE:
#   * BUILD_MODEL_HEADERS_DIR    - needed for the base dir to include.
#   * BUILD_MODEL_IS_SO_FILE     - needed to know if it is a shared lib
#   * BUILD_MODEL_RESULTS        - additional build results
#   * BUILD_MODEL_LINKFLAGS      - additional link flags
#   * BUILD_MODEL_INSTALL_SCRIPT - additional install script if needed
#   * BUILD_MODEL_BANNER         - text banner to display
#
#  Generally required to be set by the including makefile:
#   * COMPONENT - The name of the component.  SHOULD NOT CONTAIN A SPACE.
#                 Example is 'COMPONENT := PmSystem'
#   * DEPENDS_ON_PUBLIC - Components that this one depends on, in a public way.
#                         You'll get their public headers added to your include
#                         path (assuming they are already unpacked and have
#                         public headers).
#                         Example is 'DEPENDS_ON_PUBLIC := PartsLib'.
#   * DEPENDS_ON_PROTECTED - Components that this one depends on, in a protected
#                            way.  You'll get their public AND protected headers
#                            added to your include path (assuming they are
#                            already unpacked and have public or protected
#                            headers).
#   * OBJS - Objects that this module depends on.  Can be generated by C
#            or assembly (TODO: add C++)
#            Example: 'OBJS := PmSystemLib68K.o PmSystemLib.o'
#   * COMPONENT_CFLAGS  - (Optional) extra C flags to append.
#   * COMPONENT_CXXFLAGS  - (Optional) extra C++ flags to append.
#   * COMPONENT_SO_NAME - (Optional) lets you override the .so name.  TODO:
#                         should remove this option and base .so name on DB Name
#                         if it is defined, since that's the only time we need
#                         this right now.  We can't do that until we fix _everyone_ to
#                         _everyone_ to do that, though.
#   * COMPONENT_LINKFLAGS - (Optional) extra flags for linking.
#   * EXTRA_HEADER_DIRS   - (Optional) You can include extra include paths if needed
#
#  We also require the following from higher up in the build system.  These
#  get set by our "dist" makefile, which in turn gets many of the things from
#  WindRiver's build system.  Specifically note that the CC, CXX, ... come from
#  the "CONFIGURE_TARGET" variable.
#   * CC, CXX, CFLAGS, ... - Should be setup for cross compiling.
#   * BUILD_TYPE    - Should be "debug" or "release".
#   * TOOLS_DIR     - The location of tools.  This includes compilers but
#                     also includes Palm-specific tools.
#                     Like .../build/bin
#   * LIB_DIR       - The location of the gcc libs.
#                     Like .../build/arm-wrs-linux-gnueabi/lib
#   * INCLUDE_DIR   - The location of the includes.
#                     Like .../build/arm-wrs-linux-gnueabi/include
#   * INSTALL_DIR   - The directory that we should be installed to.
#                     Like .../INSTALL_STAGE/PmSystem-1.0A-L
#
#
#  Targets that are used by the build system to call us:
#   * clean          - Try to undo anything that was done by this Makefile.
#                      Will remove generated files, like object files,
#                      installed files, installed headers, etc.
#   * install -      - Installs things into INSTALL_DIR.  Also may install
#                      .so files into LIB_DIR.
#   * [default]      - Used to build "all"; should create build results
#

#################################################################
# Common to all builds in the Palm build system
#
# These are common to all different "BUILD MODELS".  Note that
# since this is not a completely generic Makefile, we are free
# to assume that we're compiling for Palm components.
#################################################################

##
# This is a list of all _possible_ types of output files that are
# created by the build system (in other words, they can be generated
# from the source files).  This is used for two reasons: to know what to
# remove upon a "clean" build and to make sure that all outputs depend on
# the Makefiles.  This doesn't include things in the "install" directory.
OUTPUTS     := *.so *.bin *.o *.gcno *.tmp *.d *.list GenSrc/*


##
# Here's where we can find various types of files.
vpath %.c   Src
vpath %.cpp Src
vpath %.s   Src


# List of my header directories, for use with a -I flag.
MY_HEADER_DIRS  := $(call SubDirs,  Incs)

# List of my header files
MY_HEADER_FILES := $(call SubFiles, Incs)


# Here's how headers work:
# * We include our Src directory.
# * We include all folders in the trees of the components that we depend on,
#   sometimes public and sometimes public and protected.  These are put in
#   temporary variables to make debugging easier with "showvar" (see above).
# * We include our own headers.

# Add BUILD_MODEL specific header
HEADER_DIRS := Src
HEADER_DIRS += $(BUILD_MODEL_HEADER_DIRS)
HEADER_DIRS_PUB := $(foreach comp, $(DEPENDS_ON_PUBLIC) $(DEPENDS_ON_PROTECTED), \
                     $(call SubDirs,  $(INCLUDE_DIR)/$(comp)/IncsPublic) \
                    )
HEADER_DIRS_PRO := $(foreach comp, $(DEPENDS_ON_PROTECTED), \
                     $(call SubDirs,  $(INCLUDE_DIR)/$(comp)/IncsProtected) \
                    )
HEADER_DIRS += $(HEADER_DIRS_PUB) $(HEADER_DIRS_PRO)
HEADER_DIRS += $(MY_HEADER_DIRS)
HEADER_DIRS += $(EXTRA_HEADER_DIRS)	# Component specific header dirs
HEADER_DIRS += $(BUILD_MODEL_HEADER_DIRS) # Build model specific header dirs

##
# Set the CFLAGS variable, which is used when compiling C files.
#
# Here are explanations of the CFLAGS:
#  * -fPIC - Generate "position independent code, which is needed for
#            shared objects.  We add this below just for .so files.
#  * -g - Create debug symbols.  We always do this, then we can strip
#         stuff out later.  This allows us to debug even on a release ROM.
#  * -Wall - Enable "all" warnings.
#  * -Wno-multichar - Don't warn about using 4-character constants, like
#                     'psys'.  Yes, we know that they're non-portable but
#                     we like 'em anyway.  Sorry!
#  * -Werror - Treat all warnings as errors
#  * -Wwrite-strings -When compiling C, give string constants the type const
#                     char[length] so that copying the address of one into
#                     a non-const char * pointer will get a warning; when
#                     compiling C++, warn about the deprecated conversion from
#                     string constants to char *. These warnings will help you
#                     find at compile time code that can try to write into a
#                     string constant, but only if you have been very careful
#                     about using const in declarations and prototypes
#  * -D_REENTRANT - Tells stdlib calls that we're going to be using
#                   pthreads.  TODO: Isn't this redundant with -pthread?
#  * -pthread - Adds various compiler flags relating to pthreads.
#  * -Ox - Sets the optimization level.  Standard levels are -Os (optimize
#          for size), -O0 (don't optimize at all), -O1 (minimal optimization),
#          -O2 (optimize for speed).  We typically use -O1 for debug builds
#          (since lower optimization is easier to debug) and -Os for release
#          builds (since it's smaller/faster).
#  * -DNDEBUG - Some code uses this to know that we're not debugging
#  * -DRELEASE - Some code uses this to know that we're not debugging
#  * -DERROR_CHECK... - Sets the error check level, which is used by PalmOS
#                       headers to control some error checking.
#  * -I... - Add includes into the system include path.
#  * $(COMPONENT_CFLAGS) - Component specific flags
#
# TODO:
# - We are getting CFLAGS on command line, but for now we ignore them.
# - Should we use -pipe?
# - Put back in defines for DEBUG and NDEBUG for debug and release ROMs?
# - Go back to -Os for production once we verify.

GCC_COMPILEFLAGS := \
	-Wall -Wno-multichar  \
	-Wwrite-strings \
	-D_REENTRANT -pthread \
	-isystem $(INCLUDE_DIR) \
	$(addprefix -I, $(HEADER_DIRS)) \
	-fno-omit-frame-pointer \
	-g

# When -Os works for all Palm components, consider changing the release
# optimization back to -Os (or even go to -O2)
ifeq ("$(BUILD_TYPE)","release")
	GCC_COMPILEFLAGS += \
		-DRELEASE -DERROR_CHECK_LEVEL=1
else
	GCC_COMPILEFLAGS += \
		-D_DEBUG -DERROR_CHECK_LEVEL=2
endif

# Shared objects need the PIC flag.  See above for description
ifeq ("$(BUILD_MODEL_IS_SO_FILE)", "yes")
	GCC_COMPILEFLAGS += -fPIC
endif

ifeq ("$(BUILD_GCOV)","1")
	GCC_COMPILEFLAGS += -fprofile-arcs -ftest-coverage -O0
endif

override CFLAGS := \
	$(GCC_COMPILEFLAGS) \
	$(PALM_CC_OPT) \
	$(PALM_CC_EXTRA) \
	$(COMPONENT_CFLAGS) \

##
# Set the CXXFLAGS variable, which is used when compiling C++ files.
#
# For now they are the same as the CFLAGS except:
# - If building for coverage, some extra flags are added
# - COMPONENT_CXXFLAGS is used instead of COMPONENT_CFLAGS
#
#  * $(COMPONENT_CXXFLAGS) - Component specific flags for C++

ifeq ("$(BUILD_GCOV)","1")
	GCC_COMPILEFLAGS += -fno-default-inline -fkeep-inline-functions
endif

override CXXFLAGS := \
	$(GCC_COMPILEFLAGS) \
	$(PALM_CXX_OPT) \
	$(PALM_CXX_EXTRA) \
	$(COMPONENT_CXXFLAGS)

ifeq ("$(BUILD_MODEL_IS_SO_FILE)", "yes")

#################################################################
# Builds for .so files that are part of the PARTS world
#################################################################

##
# Default to the propoer "so" name if not defined.

ifndef COMPONENT_SO_NAME
    COMPONENT_SO_NAME := lib$(COMPONENT).so
endif

##
# Setup the RESULTS variable.  This contains all of the desirable
# results of the build.  For all builds of this model, we build
# a ".so" file called "lib$(COMPONENT).so".

RESULTS := $(COMPONENT_SO_NAME) $(BUILD_MODEL_RESULTS)

##
# The BUILD_RESULTS variable is just _slightly_ different than the
# RESULTS variable.  It is the set of files that anyone needing to
# use this module might need.  The main difference is that the
# include files are part of this list, since someone compiling against
# thismodule would need them.

BUILD_RESULTS := $(RESULTS) $(MY_HEADER_FILES)


##
# Shared objects need the PIC flag.  See above for description

CFLAGS += -fPIC
CXXFLAGS += -fPIC


##
# The 'all' rule for .so files
#
# All we do here is depend on our results.  We also depend on the
# build results.  As part of "all", we install the headers.  This is
# a good idea since we kill them as part of "clean".
#
# ...note that because dependencies are unordered, the headers won't be
# installed until _after_ all of our stuff is build.  This is fine, since
# we always get our headers locally (only other people need our headers
# to be linked).  TODO: Should clean really kill the header link?

.PHONY: all
all: $(RESULTS)


##
# The 'install' rule for .so files
#
# This is one of the few rules in the Makefile that does something
# no matter what (it doesn't do dependency checking).  This always
# blows away the old install directory and copies everything into
# the place that it should go.
#
# ...most things get put into the "install dir", except that we
# also install a copy of the ".so" file in the library dir (so
# that other people can link against it).
#
# TODO: Do we want to copy to LIB_DIR, or make a symlink?  Should
#       that really be part of "install", or something else?

.PHONY: install
install:: all
	@bannerMakefile=$(BUILD_MODEL_BANNER); bannerCommand=install; bannerTarget=$(INSTALL_DIR); $(SHOW_BANNER)

ifeq ("$(BUILD_GCOV)","1")
	$(HUSH) install -d -m 777 $(INSTALL_DIR)$(patsubst $(W)%,/var/zgcovout%,$(SOURCE_DIR))
	$(HUSH) mv *.gcno $(INSTALL_DIR)$(patsubst $(W)%,/var/zgcovout%,$(SOURCE_DIR))
endif

	$(BUILD_MODEL_INSTALL_SCRIPT)

##
# The 'stage' rule for .so files

.PHONY: stage
stage:
	@bannerMakefile=$(BUILD_MODEL_BANNER); bannerCommand=stage; $(SHOW_BANNER)
	$(HUSH) rm -rf $(INCLUDE_DIR)/$(COMPONENT)
	$(HUSH) if [ -d Incs ]; then \
		mkdir -p $(INCLUDE_DIR); \
		cp -a Incs $(INCLUDE_DIR)/$(COMPONENT); \
	fi
	$(HUSH) install -D $(COMPONENT_SO_NAME) $(LIB_DIR)/$(COMPONENT_SO_NAME)

##
# The 'clean' rule for .so files
#
# Tries to undo everything that this Makefile did.  It deletes any
# generated outputs, deletes the build results, deletes the symlink
# to the include file, and deletes our installed files.
#
# We do a '-f' with all of the RMs, since then it doesn't yell at
# us if the file doesn't exist.

.PHONY: clean
clean:
	@bannerMakefile=$(BUILD_MODEL_BANNER); bannerCommand=clean; $(SHOW_BANNER)
	$(HUSH) rm -f  $(OUTPUTS)
	$(HUSH) rm -rf $(INCLUDE_DIR)/$(COMPONENT)
	#$(HUSH) rm -rf $(INSTALL_DIR)


##
# Build a single .o file containing all of the other .o files for this
# shared library.  This allows us to localize the symbols against an
# "exported" list.
#
# TODO: Actually do that.  Right now, I'm not localizing...  Should localize
# given the .mdf file, or maybe an _exports.txt file?
#
#lib$(COMPONENT).o : $(OBJS) $(wildcard _exports.txt)
#	@# Link all the .o files into one .o file, without finishing yet.
#	$(LD) -r -o $@.tmp $(filter %.o,$^)
#
#	@# Output the list of global symbols, stripping the external references (U).
#	$(NM) -g $@.tmp | grep -v '^         U' | awk '{ print $$3; }' > $(@:%.o=%.gsym.tmp)
#
#	@# Put the exports in a form that grep will like.  Strip lines starting with # and
#	@# put ^ and $ around each line
#	$(SED) 's/^\([^# \t]*\).*$$/^\1$$/' $(filter %/_exports.txt,$^) > $(@:%.o=%.exp.tmp)
#
#	@# Use grep to create a list of symbols to _localize_
#	$(GREP) -v -f $(@:%.o=%.exp.tmp) $(@:%.o=%.gsym.tmp) > $(@:%.o=%.loc.tmp)
#
#	@# Use objcopy to localize
#	$(OBJ_COPY) --localize-symbols $(@:%.o=%.loc.tmp) $@.tmp $@

$(COMPONENT_SO_NAME:.so=.o): $(OBJS)
	@bannerMakefile=$(BUILD_MODEL_BANNER); bannerCommand=tgt_LD_1; bannerTarget=$(@F); $(SHOW_BANNER)
	$(HUSH) $(LD) \
		-r \
		-o $@ \
		$(filter %.o,$^)


##
# Build the link flags
#
# -fPIC     Generate "position independent code, which is needed for shared
#           objects.  We add this below just for .so files.
# -shared   Produce a shared object which can then be linked with other objects
#           to form an executable.
# -lpthread To link with pthread: TODO each component must specify to link with pthread or not
# -pthread  Adds various compiler flags relating to pthreads. (?)
# --version-script
#           If an export map file is found it is used!
# Add component specific link flag

GCC_LINKFLAGS := \
	-fPIC -shared \
	-lpthread -pthread \
	-Wl,--warn-common \
	-Wl,-rpath-link $(LIB_DIR) \
	-L$(LIB_DIR) \

has_export_map := $(wildcard Src/$(COMPONENT)Exports.map)

ifneq ($(strip $(has_export_map)),)

GCC_LINKFLAGS += \
    -Wl,--version-script=Src/$(COMPONENT)Exports.map

endif

ifeq ("$(BUILD_GCOV)","1")
	GCC_LINKFLAGS += -fprofile-arcs -ftest-coverage
endif

# Add component specific link flags
GCC_LINKFLAGS += \
	$(COMPONENT_LINKFLAGS)

##
# Build the shared library.  We always build the shared library from
# a single .o file, which we have used to "localize" the symbols.
#
# TODO:
#		-Wl,--no-undefined \
#		\
#		$(foreach comp, $(DEPENDS_ON_PUBLIC) $(DEPENDS_ON_PROTECTED), \
#		  -L../lib$(comp) -l$(comp) \
#		 )

$(COMPONENT_SO_NAME): $(COMPONENT_SO_NAME:.so=.o) $(strip $(has_export_map))
	@bannerMakefile=$(BUILD_MODEL_BANNER); bannerCommand=tgt_LD_2; bannerTarget=$(@F); $(SHOW_BANNER)
	$(HUSH) $(CC) -o $@ $< $(GCC_LINKFLAGS)
ifeq ($(strip $(has_export_map)),)
	$(warning "Warning: Missing file Src/$(COMPONENT)Exports.map for your component where you should declare the exported functions")
endif

else # ("$(BUILD_MODEL_IS_SO_FILE)", "no")

#################################################################
# Builds for executable files that are part of the PARTS world
#
# There's some duplication with the ".so" case, but I think it's
# simpler/cleaner to have some duplication at this point.
#################################################################

##
# Setup the RESULTS variable.  This contains all of the desirable
# results of the build.
RESULTS := $(COMPONENT) $(BUILD_MODEL_RESULTS)


##
# We don't currently allow exporting header files for executables,
# so BUILD_RESULTS is just the same as RESULTS...
# Add build model specific result
BUILD_RESULTS := $(RESULTS)

##
# The 'all' rule for executables
#
# All we do here is depend on our results.
.PHONY: all
all: $(RESULTS)


##
# The 'install' rule for executables
#
# This is one of the few rules in the Makefile that does something
# no matter what (it doesn't do dependency checking).  This always
# blows away the old install directory and copies everything into
# the place that it should go.
.PHONY: install
install:: all
	@bannerMakefile=$(BUILD_MODEL_BANNER); bannerCommand=install; bannerTarget=$(INSTALL_DIR); $(SHOW_BANNER)

	#$(HUSH) rm -rf                                  $(INSTALL_DIR)
	$(HUSH) install -d     $(INSTALL_DIR)/usr/bin
	$(HUSH) install -m 775 $(COMPONENT) $(INSTALL_DIR)/usr/bin/$(COMPONENT)

	$(HUSH) install -d     $(INSTALL_DIR)/etc/pmwsf
	cp -rf etc/ $(INSTALL_DIR)/

	$(HUSH)install -m 0755 service/com.palm.wsf.json.prv $(INSTALL_DIR)/usr/share/dbus-1/system-services/com.palm.wsf.json

ifeq ("$(BUILD_GCOV)","1")
	$(HUSH) install -d -m 777 $(INSTALL_DIR)$(patsubst $(W)%,/var/zgcovout%,$(SOURCE_DIR))
	$(HUSH) mv *.gcno $(INSTALL_DIR)$(patsubst $(W)%,/var/zgcovout%,$(SOURCE_DIR))
endif

##
# The 'clean' rule for executables
#
# Tries to undo everything that this Makefile did.  It deletes any
# generated outputs, deletes the build results, deletes the staged include
# directory, and deletes our installed files.
#
# We do a '-f' with all of the RMs, since then it doesn't yell at
# us if the file doesn't exist.

.PHONY: clean
clean:
	@bannerMakefile=$(BUILD_MODEL_BANNER); bannerCommand=clean; $(SHOW_BANNER)
	$(HUSH) rm -f  $(COMPONENT)
	$(HUSH) rm -f  $(OUTPUTS)
	$(HUSH) rm -rf $(INCLUDE_DIR)/$(COMPONENT)
	#$(HUSH) rm -rf $(INSTALL_DIR)

##
# The 'stage' rule for executables

.PHONY: stage
stage:
	@bannerMakefile=$(BUILD_MODEL_BANNER); bannerCommand=stage; $(SHOW_BANNER)
	$(HUSH) rm -rf $(INCLUDE_DIR)/$(COMPONENT)
	$(HUSH) if [ -d Incs ]; then \
		mkdir -p $(INCLUDE_DIR); \
		cp -a Incs $(INCLUDE_DIR)/$(COMPONENT); \
	fi

##
# Build the executable.
#
# This is really just for Parts and PartsCtrl.  If you're thinking about
# using it directly for another executable, you're probably wrong.
#
# TODO: Don't hardcode all of the "-L" stuff, pass it in.

APP_LINKFLAGS :=
ifeq ("$(BUILD_GCOV)","1")
	APP_LINKFLAGS += -fprofile-arcs -ftest-coverage
endif

$(COMPONENT): $(OBJS)
	@bannerMakefile=$(BUILD_MODEL_BANNER); bannerCommand=tgt_LD; bannerTarget=$(@F); $(SHOW_BANNER)
	$(HUSH) $(CC) -o $@ $^ \
		-lpthread -pthread \
		-lrt \
		-ldl \
		-Wl,-rpath-link $(LIB_DIR) \
		-L$(LIB_DIR) \
		$(BUILD_MODEL_LINKFLAGS) \
		$(COMPONENT_LINKFLAGS) \
		$(APP_LINKFLAGS)
endif # ifeq ("$(IS_PARTS_SO_FILE)", "no")


#################################################################
# Common stuff that needs to come last
#################################################################

##
# Include rules for compiling ".cpp", ".c", ".s", and ".S" files to ".o" files
include $(MAKEFILES_DIR)/CompileRules.mk

##
# Define a rule to create a symlink: $(INCLUDE_DIR)/$(COMPONENT) => Incs
#$(eval $(call DirSymlinkRuleTemplate, $(INCLUDE_DIR)/$(COMPONENT), Incs))

##
# Make all outputs depend on the Makefiles, so that if a Makefile
# changes we rebuild _everything_.  We do this at the end of the
# makefile so that when we use "$<" above to refer to the first
# dependency we get the right thing.
$(wildcard $(OUTPUTS)): $(FILTERED_MAKEFILE_LIST)


##
# Include dependency files that were generated with the previous build.
# See section above (in the %.o : %.c rule) for details.
#
# Note: we never include .d files for a clean build so that a corrupt
# .d file doesn't prevent us from doing a clean (which will wipe out .d files).
ifneq ($(MAKECMDGOALS),clean)
    D_FILES := $(wildcard *.d)
    ifdef D_FILES
        include $(D_FILES)
    endif
endif
